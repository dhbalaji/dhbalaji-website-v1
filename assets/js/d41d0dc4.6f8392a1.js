"use strict";(self.webpackChunkblog2=self.webpackChunkblog2||[]).push([[4729],{55324:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>n,toc:()=>l});var n=a(91780),s=a(86070),o=a(20887);const c={title:"Cache busting GET calls with cache-control headers",tags:["frontend"],date:new Date("2020-12-09T07:58:41.000Z"),authors:["dhbalaji"]},i=void 0,r={authorsImageUrls:[void 0]},l=[];function h(e){const t={img:"img",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"cache calls",src:a(91917).A+"",width:"1280",height:"853"})}),"\n",(0,s.jsx)(t.p,{children:"One of the performance optimization techniques is to serve data from the cache and lookup for the network if the cache fails. It's called cache first then network strategy. Life moves fast and if the API has to get updated information, it's impossible because we are reading the cache always. Is there a way to bypass cache in this setup? Yes, it's cache-control headers."})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},91917:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/cachecalls-71b6e4b4ae9f3d378584be651895d7d2.webp"},20887:(e,t,a)=>{a.d(t,{R:()=>c,x:()=>i});var n=a(30758);const s={},o=n.createContext(s);function c(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),n.createElement(o.Provider,{value:t},e.children)}},91780:e=>{e.exports=JSON.parse('{"permalink":"/blog/Cache-busting-get-calls-with-cache-control-headers","source":"@site/blog/Cache-busting-get-calls-with-cache-control-headers.md","title":"Cache busting GET calls with cache-control headers","description":"cache calls","date":"2020-12-09T07:58:41.000Z","tags":[{"inline":true,"label":"frontend","permalink":"/blog/tags/frontend"}],"readingTime":6.775,"hasTruncateMarker":true,"authors":[{"name":"D Balaji","title":"Lead Design Technologist","url":"https://github.com/dhbalaji","imageURL":"https://avatars.githubusercontent.com/u/3672491?v=4","key":"dhbalaji","page":null}],"frontMatter":{"title":"Cache busting GET calls with cache-control headers","tags":["frontend"],"date":"2020-12-09T07:58:41.000Z","authors":["dhbalaji"]},"unlisted":false,"prevItem":{"title":"WFH vs Remote working & the WFH allowance analysis","permalink":"/blog/WFH-vs-Remote-working"},"nextItem":{"title":"Understanding google data storage options in GCP","permalink":"/blog/Understanding-google-data-storage-options-in-GCP"}}')}}]);